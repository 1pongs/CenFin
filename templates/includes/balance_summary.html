<div id="account-balance-wrapper" class="mb-3 small text-muted d-none">
  <div class="d-flex align-items-center">
    <label class="form-label me-2 mb-0">Pair balance:</label>
    <span id="pair-balance-field" style="display:inline-block"></span>
  </div>
  <div class="d-flex align-items-center mt-1">
    <label class="form-label me-2 mb-0">Account balance:</label>
    <span id="account-balance-field" style="display:inline-block"></span>
  </div>
  <div id="account-balance-spinner" class="spinner-border spinner-border-sm text-secondary ms-2 d-none" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</div>
<div id="balance-error" class="text-danger small d-none"></div>
<div id="balance-hint" class="text-warning small d-none"></div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const accField = document.getElementById('id_account_source');
    const entField = document.getElementById('id_entity_source');
    const txTypeField = document.getElementById('id_transaction_type');
    const accWrapper = document.getElementById('account-balance-wrapper');
    const pairBalanceField = document.getElementById('pair-balance-field');
    const accBalanceField = document.getElementById('account-balance-field');
    const accSpinner = document.getElementById('account-balance-spinner');
    const errorDiv = document.getElementById('balance-error');
    const hintDiv = document.getElementById('balance-hint');
    const form = document.querySelector('#form-container form');
    const saveBtn = form ? form.querySelector('button[type="submit"],input[type="submit"]') : null;
    const amountInput = form ? form.querySelector('input.amount-input') : null;

    const showTypes = new Set(['expense', 'transfer']);
  let lastReqId = 0;

    function parseAmt(txt) {
      const num = parseFloat(String(txt).replace(/[^0-9.-]/g, ''));
      return isNaN(num) ? 0 : num;
    }

    function isOutside(select) {
      if (!select) return false;
      const opt = select.options[select.selectedIndex];
      return opt && opt.text.trim() === 'Outside';
    }

    function checkHint() {
      hintDiv.classList.add('d-none');
      if (!amountInput) return;
      const amt = parseAmt(amountInput.dataset.raw || amountInput.value);
      const accBal = parseAmt(accBalanceField.textContent);
      if (amt > 0 && accBal > 0 && accBal < amt) {
        hintDiv.textContent = 'Note: Account balance is lower than Amount; this will be blocked even if the pair has funds.';
        hintDiv.classList.remove('d-none');
      }
    }

    function getTxType() {
      if (!txTypeField) return null; // acquisition form has no type select
      const val = (txTypeField.value || '').toString().trim().toLowerCase();
      return val;
    }

    function shouldShowForType() {
      const t = getTxType();
      // When no transaction_type field exists (e.g., Acquisition form), show the widget.
      if (t === null) return true;
      return showTypes.has(t);
    }

    function insertFields() {
      if (accField) accField.insertAdjacentElement('afterend', accWrapper);
    }
    async function fetchPairBalance(acc, ent) {
      const reqId = ++lastReqId;
      // Make the wrapper visible while loading so users always see the label
      accWrapper.classList.remove('d-none');
      accSpinner.classList.remove('d-none');
      pairBalanceField.textContent = '';
      accBalanceField.textContent = '';
      errorDiv.classList.add('d-none');
      hintDiv.classList.add('d-none');
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 5000);
  // Request the true pair balance only (no fallback to account balance)
  const url = `/transactions/pair-balance/?account=${acc}&entity=${ent}&fallback=0`;
        const resp = await fetch(url, { signal: controller.signal });
        clearTimeout(timeout);
        if (reqId !== lastReqId) return; // stale response; ignore
        if (resp.ok) {
          const data = await resp.json();
          if (reqId !== lastReqId) return; // stale after parse; ignore
          const amt = parseFloat(data.balance);
          if (!isNaN(amt)) {
            pairBalanceField.textContent = `${data.currency} ${amt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            accWrapper.classList.remove('d-none');
            errorDiv.classList.add('d-none');
          } else {
            accWrapper.classList.add('d-none');
            errorDiv.textContent = 'Could not parse balance.';
            errorDiv.classList.remove('d-none');
          }
        } else {
          // Attempt to read server-provided JSON error
          let errText = 'Failed to load balance.';
          try {
            const data = await resp.json();
            if (data && data.error) errText = data.error;
            console.error('pair-balance error', data);
          } catch (e) {
            try {
              const txt = await resp.text();
              if (txt) console.error('pair-balance non-JSON error', txt);
            } catch (_) {}
          }
          accWrapper.classList.add('d-none');
          errorDiv.textContent = errText;
          errorDiv.classList.remove('d-none');
        }
      } catch (err) {
        accWrapper.classList.add('d-none');
        errorDiv.textContent = 'Error fetching balance.';
        errorDiv.classList.remove('d-none');
      } finally {
        // continue to fetch account balance regardless; spinner will be hidden after both calls
      }
    }

    async function fetchAccountBalance(acc) {
      const reqId = ++lastReqId;
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 5000);
        const url = `/transactions/account-balance/${acc}/`;
        const resp = await fetch(url, { signal: controller.signal });
        clearTimeout(timeout);
        if (reqId !== lastReqId) return;
        if (resp.ok) {
          const data = await resp.json();
          const amt = parseFloat(data.balance);
          if (!isNaN(amt)) {
            accBalanceField.textContent = `${data.currency} ${amt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
          }
        }
      } catch (e) {
        // swallow account balance errors silently
      } finally {
        accSpinner.classList.add('d-none');
        checkHint();
      }
    }

    function updatePair() {
      const acc = accField && accField.value;
      const ent = entField && entField.value;
      if (!accField || !entField) {
        // Required fields not mounted yet
        accWrapper.classList.add('d-none');
        accBalanceField.textContent = '';
        return;
      }
      if (acc && ent) {
        // Only show for configured transaction types (expense/transfer)
        if (shouldShowForType()) {
          // Request the true pair balance only (no fallback to account balance)
          fetchPairBalance(`${acc}`, `${ent}`);
          fetchAccountBalance(`${acc}`);
        } else {
          accWrapper.classList.add('d-none');
          pairBalanceField.textContent = '';
          accBalanceField.textContent = '';
        }
      } else {
        accWrapper.classList.add('d-none');
        pairBalanceField.textContent = '';
        accBalanceField.textContent = '';
      }
      checkHint();
    }

    // Move the balance summary under the Account Source field
    insertFields();
    // Try immediately, and again after a short delay to catch late-rendered selects
    updatePair();
    setTimeout(updatePair, 150);
    setTimeout(updatePair, 400);

    if (accField) accField.addEventListener('change', updatePair);
    if (entField) entField.addEventListener('change', updatePair);
    if (txTypeField) txTypeField.addEventListener('change', updatePair);
    if (amountInput) amountInput.addEventListener('input', checkHint);
  });
  </script>
